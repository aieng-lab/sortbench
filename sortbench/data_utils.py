import inflect
import json
import os
import random
import string

from nltk.corpus import wordnet

def generate_unsorted_list(n=10, type='integer', **kwargs):
    """
    Generate a list of n random values of the given type.

    The random seed should be controlled by the caller if reproducibility is desired. Use random.seed() from the random module.

    Parameters:
    - n: the number of values to generate (default: 10)
    - type: the type of the values to generate. Possible values are: 'integer', 'float', 'string', 'word', 'number_string', 'prefix_string', 'prefix_words' (default: 'integer')
    - min_value: the minimum value for the generated values (optional, only for numeric types, default: 0)
    - max_value: the maximum value for the generated values (optional, only for numeric types, default: 100)

    Returns:
    - a list of n values of the given type
    """
    if n<=0:
        raise ValueError("n must be a positive integer")
    if type not in ['integer', 'float', 'string', 'word', 'number_string', 'prefix_string', 'prefix_words']:
        raise ValueError("Type must be 'integer', 'float', 'string', 'word', 'number_string', 'prefix_string', or 'prefix_words'")
    min_value = kwargs.get('min_value', 0)
    max_value = kwargs.get('max_value', 100)
    if not isinstance(min_value, int) or isinstance(min_value, float):
        raise ValueError("min_value must be an integer or float")
    if not isinstance(max_value, int) or isinstance(max_value, float):
        raise ValueError("max_value must be an integer or float")
    if min_value >= max_value:
        raise ValueError("min_value must be less than max_value")

    if type == 'integer':    
        return [random.randint(min_value, max_value) for _ in range(n)]
    elif type == 'float':
        return [random.uniform(min_value, max_value) for _ in range(n)]
    elif type == 'string':
        return [''.join(random.choices(string.ascii_letters, k=5)) for _ in range(n)]
    elif type == 'word':
        words = list(set(wordnet.words()))
        words = [word for word in words if "'" not in word]
        return random.sample(words, n)
    elif type == 'number_string':
        p = inflect.engine()
        return [p.number_to_words(random.randint(min_value, max_value)) for _ in range(n)]
    elif type == 'prefix_string':
        prefix_letter = random.choice(string.ascii_letters)
        return [f"{prefix_letter*3}{''.join(random.choices(string.ascii_letters, k=5))}"  for _ in range(n)]
    elif type == 'prefix_words':
        prefix_letter = random.choice(string.ascii_letters)
        words = list(set(wordnet.words()))
        words = [word for word in words if "'" not in word]
        return [f"{prefix_letter*3}{random.choice(words)}" for _ in range(n)]
    else:
        raise ValueError("Unknown type")
    
def generate_json_file(file, num_lists, generator):
    """
    Generate a JSON file with num_lists lists of random data generated by the generator function.

    Parameters:
    - file: the name of the file to write
    - num_lists: the number of lists to generate
    - generator: a function that generates a list of random data
    """
    data = {}
    for i in range(num_lists):
        data[f'list_{i+1}'] = generator()
    with open(file, 'w') as f:
        f.write(json.dumps(data))

def generate_benchmark_data(path, name, version, num_lists, sizes, types):
    """
    Generate benchmark data for a given name, sizes, and types.
    The data is written to the folder 'benchmark_data', with one JSON file per size and type.

    Parameters:
    - path: the path to the folder where the data files will be written
    - name: the name of the benchmark data
    - version: the version of the benchmark data
    - num_lists: the number of lists to generate
    """
    max_digits = len(str(max(sizes)))
    for size in sizes:
        for type in types:
            # use pathlib to create the file path
            size_str = str(size).zfill(max_digits)
            file = os.path.join(path, f'{name}_{version}_{type}_{size_str}.json')
            os.makedirs(os.path.dirname(file), exist_ok=True)
            generate_json_file(file, num_lists, lambda: generate_unsorted_list(size, type))

def load_data_local(file_path='benchmark_data', name='sortbench', mode='basic', version='v1.0'):
    """
    Load all data from a local directory into a dict of dicts.

    Parameters:
    file_path (str): path to directory containing data files (default: 'benchmark_data')
    name (str): name of the benchmark data (default: 'sortbench')
    mode (str): mode of the benchmark data (default: 'basic')
    version (str): version of the benchmark data (default: 'v1.0')
    """
    configs = {}

    # fetch all filenames from file_path and filter by name
    filenames = os.listdir(file_path)
    filenames = sorted([filename for filename in filenames if filename.startswith(f'{name}_{mode}_{version}_')])

    # load all data into configs dict
    for filename in filenames:
        with open(f'{file_path}/{filename}', 'r') as f:
            data = json.load(f)
            configs[filename] = data

    return configs